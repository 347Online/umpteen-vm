use std::{
    fs::{self, read_to_string},
    path::PathBuf,
};

use clap::{Args, Parser, Subcommand};
use umpteen::{
    asm::assemble,
    lexer::{Lexer, Token},
    parser::AstParser,
    vm::Vm,
};

#[derive(Debug, Args)]
struct IrArgs {
    /// File to read from
    file: String,
    /// Suppress debug output
    #[arg(short, long)]
    quiet: bool,
    /// Write output to file
    #[arg(short = 'E', long)]
    emit: bool,
}

#[derive(Debug, Subcommand)]
enum Commands {
    /// Assemble Umpteen bytecode from instructions file
    Assemble {
        #[clap(flatten)]
        args: IrArgs,
        /// Execute generated bytecode
        #[arg(short, long)]
        exec: bool,
    },
    /// Scan src file to generate tokens
    Lex(IrArgs),
    /// Parse tokens to AST
    Parse(IrArgs),
}

#[derive(Debug, Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

fn main() -> anyhow::Result<()> {
    let args = Cli::parse();

    macro_rules! emit_json {
        ($repr:expr, $file:ident, $name:literal, $ext:literal) => {
            anyhow::Result::<()>::Ok({
                let outdir = PathBuf::from("./out");
                let outfile = outdir.join($file).with_extension($ext);
                let json = serde_json::to_string_pretty($repr)?;
                std::fs::write(&outfile, json)?;
                println!(
                    concat!("Wrote ", $name, " to {}"),
                    outfile.canonicalize()?.to_str().unwrap()
                )
            })
        };
    }

    use Commands as C;
    match args.command {
        C::Assemble {
            args: IrArgs { quiet, emit, file },
            exec,
        } => {
            let instrs = assemble(&file)?;

            if !quiet {
                dbg!(&instrs);
            }

            if emit {
                emit_json!(&instrs, file, "bytecode", "u.json")?
            }

            if exec {
                let mut vm = Vm::new();
                vm.load(instrs);
                vm.run()?;
            }
        }
        C::Lex(IrArgs { file, quiet, emit }) => {
            let source = read_to_string(&file)?;
            let lexer = Lexer::new(&source);
            let tokens = lexer.scan_tokens()?;

            if !quiet {
                dbg!(&tokens);
            }

            if emit {
                emit_json!(&tokens, file, "tokens", "tokens.json")?;
            }
        }

        C::Parse(IrArgs { file, quiet, emit }) => {
            let json = read_to_string(&file)?;
            let tokens = serde_json::from_str::<Vec<Token>>(&json)?;
            let parser = AstParser::new(tokens);
            let ast = parser.parse()?;

            if !quiet {
                dbg!(&ast);
            }

            if emit {
                emit_json!(&ast, file, "AST", "json")?;
            }
        }
    }

    Ok(())
}
